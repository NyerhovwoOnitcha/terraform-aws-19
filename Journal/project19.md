## Migrate your backend to Terraform Cloud
Create an organisation and workspace in your terraform cloud account, let it be a version control workspace. Allow auto apply API, CLI AND VCS runs.

### terraform.auto.tfvars
Observe that we changed the `terraform.tfvars file` from project18 to `terraform.auto.tfvars`. Naming it this way allows terraform to automatically recognize our variables already declared in our configuration. Failure to do it this way means we will have to go set each of the variable declared in the `terraform.tfvars file` on the terraform cloud which is a bit of work.

### Set environmental variables in Terraform Cloud
Terraform Cloud needs access to the default aws profile so set the environmental variables on terraform cloud.
Set for:
```
aws_access_key_id
aws_secret_access_key
```

## CREATE AMI with PACKER.
https://developer.hashicorp.com/packer/tutorials/aws-get-started/aws-get-started-build-image

### Packer Templates: 
A packer template defines the desired configuration and settings of the image to be built., basically like it's name it's a template that defines what you want to do. It is written in HCL or JSON. It's main secions are; variables, builders, provisioners and post processors.

### Blocks of the packer template

#### Variables:
Same as variables in the context of codes. There are also environment variables e.g API keys or Credentials (AWS access keys)

#### Local Block
Used to define local values to be used in the template

#### Source Block
This block defines the configuration for a specific builder. 

#### Build Block
The core components of the template that actually creates the images, it references a source that contains the contains the configurations defined for the images. This block the build process. You can set up multiple sources and provisioners and define the order in which they are executed

#### Provisioner
Provisioners are used to install and configure software on a machine during it's building process. it allows you customize the image. Provisioners supported by packer include shell, ansible, chef,puppet, etc.

#### Post Processors
They are used in packer to modify the artifacts generated by the build after completion. Post processors allow you perform additional tasks e.g compressing, uploading or customizing the output artifacts. e.g 
 - artifice: allows you add files as artifacts 
 - shell-local: allows you execute shel command or script after a build completes
 - docker import: Used to import a docker image into a docker daemon after the build completes
 - docker push: this pushes a docker image to a docker registry after a build completes
 - vagrant: creates a vagrant box from the build artifacts
 - manifest: generates a JSON or YAML file comtaining metadata about the build artifacts

#### packer commands
`packer init nginx.pkr.hcl`
`packer validate nginx.pkr.hcl`
`packer built nginx.pkr.hcl` 


- Install packer 
- Create each of the AMi with packer

### Short notes of AMI creation.
#### Bastion AMI
You will notice that compared to when we were preparing the bastion AMI in project 15, we are doing significantly more now. A look at the bastion.sh says that. Our bastion.sh for project 15 was:
```
sudo yum install https://dl.fedoraproject.org/pub/epel/epel-release-latest-9.noarch.rpm

sudo yum install -y https://dl.fedoraproject.org/pub/epel/epel-next-release-latest-9.noarch.rpm

sudo yum install -y dnf-utils http://rpms.remirepo.net/enterprise/remi-release-9.rpm

yum install wget vim python3 telnet htop git mysql net-tools chrony -y

systemctl start chronyd
systemctl enable chronyd
``` 

But our bastion.sh script contains more commands installing more things, this is because we didn't use ansible in project 15, in project 15 after creating all the amis, we manually SSH'd into the webservers from the bastion server. But that will not be the case here. In this case we will be using the configuraion tool to ansible to automate configuration thus, ansible will be installed on the bastion and from the bastion we will run ansible commands to configure the webservers in their private subnets, consequently java and ansible installation instructions were added  to the bastion.sh script.  

#### Nginx AMI

The only difference here is that we are adding commands to create the self signed certificate. `The subj command` helps us fill in the required parameters when creating  the certificate.

#### Webserveers AMI
Only extra thing we did here was adding commands to install java.

## Further Tinkering
After creating your ami's with packer and feeding the amis to your infrastructure the target health checks will fail, this is cos even though the instances where created i.e the listeners, they still have not been configured, for the reverse proyy instance nginx has not been installed and thus /healthstatus has not been configured, same with the webservers where apache has not been installed and /healthstatus has not been configured.

To solve this since our infrastucture already spins up the target, comment out:
    - Remove the instances as a listener for the loadbalancers i.e you created listeners for nginx target group and both webservers target groups which the instances, remove them.

    - The autoscaling groups is attached to the loadbalancer so comment out the autoscaling group for nginx, wordpress and tooling
    - comment out the autoscaling group attachement to the nginx, wordpress and tooling 

##  CONFIGURARION.
We've created the instances and deregistred them as targets, the next thing we want to do is to configured